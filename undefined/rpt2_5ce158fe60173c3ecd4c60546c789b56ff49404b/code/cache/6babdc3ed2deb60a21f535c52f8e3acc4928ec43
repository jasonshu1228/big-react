{"code":"import { completeWork } from './completeWork';\r\nimport { beginWork } from './beginWork';\r\nimport { createWorkInProgress } from './fiber';\r\nimport { HostRoot } from './workTags';\r\nimport { NoFlags, MutationMask } from './fiberFlags';\r\nimport { commitMutationEffects } from './commitWork';\r\n// TODO：需要一个全局的指针，指向当时正在工作的 fiberNode 树，一般是 workInProgress\r\n// 指向当前工作单元的指针\r\nlet workInProgress = null;\r\n// 用于进行初始化的操作\r\nfunction prepareFreshStack(root) {\r\n    // 初始化将指针指向第一个fiberNode（root）\r\n    workInProgress = createWorkInProgress(root.current, {});\r\n}\r\n/*\r\nmarkUpdateFromFiberToRoot 函数的作用是将一个Fiber节点的更新标记打上，\r\n然后将这个标记一直向上遍历父节点，直到遍历到根节点，将根节点的更新标记也打上。\r\n这个函数通常在一个组件内部的Fiber树上的更新发生时被调用，用于标记哪些组件需要更新，\r\n然后将这些标记一直向上冒泡，最后标记整个应用需要更新。\r\n*/\r\n// 找到根节点，从根节点开始更新整个组件\r\nfunction markUpdateFromFiberToRoot(fiber) {\r\n    let node = fiber;\r\n    let parent = node.return;\r\n    while (parent !== null) {\r\n        node = parent;\r\n        parent = node.return;\r\n    }\r\n    if (node.tag === HostRoot) {\r\n        return node.stateNode; // 此时的 HostRootFiber 指向 FiberRootNode\r\n    }\r\n    // 可能是Portal节点，也可能是 Suspense节点\r\n    return null;\r\n}\r\n// 在fiber中更新调度\r\nexport function scheduleUpdateOnFiber(fiber) {\r\n    // 调度功能 xxx\r\n    const root = markUpdateFromFiberToRoot(fiber);\r\n    renderRoot(root);\r\n}\r\n// 作用是用来创建fiber树，进而和更新流程联系起来\r\n// 那么可以推测出调用 renderRoot 应该是触发更新的 api\r\nfunction renderRoot(root) {\r\n    // 初始化\r\n    prepareFreshStack(root);\r\n    // 执行递归\r\n    do {\r\n        try {\r\n            workLoop();\r\n            break;\r\n        }\r\n        catch (e) {\r\n            // 开发环境会被编译成 true，生产环境会被编译为 false\r\n            if (true) {\r\n                console.log('workLoop发生错误', e);\r\n            }\r\n            workInProgress = null;\r\n        }\r\n    } while (true);\r\n    // 这个 finishedWork 已经是完成递归阶段两个函数生成的 workInProgress 树了\r\n    // 此时的 wip 已经包含了某些 Placement 副作用的标记了。\r\n    const finishedWork = root.current.alternate;\r\n    root.finishedWork = finishedWork;\r\n    // 根据 wip fiberNode树和树中的flags执行具体的Dom操作了。\r\n    // 接下来实行 react-dom下的首屏渲染流程了\r\n    // 从根节点开始，递归执行 commitWork\r\n    commitRoot(root);\r\n}\r\nfunction commitRoot(root) {\r\n    // root.finishedWork 为 workInProgress\r\n    const finishedWork = root.finishedWork;\r\n    if (finishedWork === null) {\r\n        return;\r\n    }\r\n    if (true) {\r\n        console.warn('commit阶段开始', finishedWork);\r\n    }\r\n    // 重置 finishedWork\r\n    root.finishedWork = null;\r\n    // 判断是否存在三个子阶段需要执行的操作\r\n    // root flags root subtreeFlags\r\n    const subtreeHasEffect = (finishedWork.subtreeFlags & MutationMask) !== NoFlags;\r\n    const rootHasEffect = (finishedWork.flags & MutationMask) !== NoFlags;\r\n    if (subtreeHasEffect || rootHasEffect) {\r\n        // beforeMutation\r\n        // 主要实现 mutation Placement\r\n        commitMutationEffects(finishedWork);\r\n        // 双缓冲树的更新\r\n        root.current = finishedWork;\r\n        // layout\r\n    }\r\n    else {\r\n        root.current = finishedWork;\r\n    }\r\n}\r\n// 该函数用于调度和执行 FiberNode 树的更新和渲染过程\r\n// 该函数的作用是处理 React 程序中更新请求，计算 FiberNode 树中的每个节点的变化，并把这些变化同步到浏览器的DOM中\r\nfunction workLoop() {\r\n    while (workInProgress !== null) {\r\n        // 开始执行每个工作单元的工作\r\n        performUmitOfWork(workInProgress);\r\n    }\r\n}\r\n// 在这个函数中，React 会计算 FiberNode 节点的变化，并更新 workInProgress\r\nfunction performUmitOfWork(fiber) {\r\n    // 如果有子节点，就一直遍历子节点\r\n    const next = beginWork(fiber);\r\n    // 递执行完之后，需要更新下工作单元的props\r\n    fiber.memoizedProps = fiber.pendingProps;\r\n    // 没有子节点的 FiberNode 了，代表递归到最深层了。\r\n    if (next === null) {\r\n        completeUnitOfWork(fiber);\r\n    }\r\n    else {\r\n        // 如果有子节点的 FiberNode，则更新子节点为新的 fiberNode 继续执行\r\n        workInProgress = next;\r\n    }\r\n}\r\n// 主要进行归的过程，向上遍历父节点以及兄弟，更新它们节点的变化，并更新 workInProgress\r\nfunction completeUnitOfWork(fiber) {\r\n    let node = fiber;\r\n    do {\r\n        // 归：没有子节点之后开始向上遍历父节点\r\n        completeWork(node);\r\n        const sibling = node.sibling;\r\n        if (sibling !== null) {\r\n            // 有兄弟节点时，将指针指到兄弟节点\r\n            workInProgress = sibling;\r\n            return;\r\n        }\r\n        // 兄弟节点不存在时，递归应该继续往上指到父亲节点\r\n        node = node.return;\r\n        workInProgress = node;\r\n    } while (node !== null);\r\n}\r\n//# sourceMappingURL=workLoop.js.map","references":["/Users/liangshuhao/Learn/coderwhy/Learn React/Big-React18-/big-react18/packages/react-reconciler/src/completeWork.ts","/Users/liangshuhao/Learn/coderwhy/Learn React/Big-React18-/big-react18/packages/react-reconciler/src/beginWork.ts","/Users/liangshuhao/Learn/coderwhy/Learn React/Big-React18-/big-react18/packages/react-reconciler/src/fiber.ts","/Users/liangshuhao/Learn/coderwhy/Learn React/Big-React18-/big-react18/packages/react-reconciler/src/workTags.ts","/Users/liangshuhao/Learn/coderwhy/Learn React/Big-React18-/big-react18/packages/react-reconciler/src/fiberFlags.ts","/Users/liangshuhao/Learn/coderwhy/Learn React/Big-React18-/big-react18/packages/react-reconciler/src/commitWork.ts"],"map":"{\"version\":3,\"file\":\"workLoop.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../packages/react-reconciler/src/workLoop.ts\"],\"names\":[],\"mappings\":\"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\"}"}
